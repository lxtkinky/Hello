野指针：堆区的内存被释放，指向堆区的栈指针没有被释放，再次调用这个栈指针就会产生野指针
内存泄漏：指向堆区的栈指针被释放了，堆区的内存空间没有释放，这块内存区域会一直存在无法释放，且无法使用

栈：是向低地址扩展的内存空间
堆：是向高地址扩展的内存空间

x/100xb array 打印100个字节内存地址 从array开始
po array 打印array

class_copyIvarList
再c 里面 copy new create 再堆区域里面开辟空间，在
create new copy 默认都会开辟堆空间（都会调用malloc）

CFRunloopRef *observer = 初始化;
free(observer);
CFRelease(observer);  的区别
observer 里面有可能存放了其他堆内存的指针，如果用free(observer) 会直接释放observer所指向的堆内存，而不会释放observer堆内存中保存的指针所指向的堆内存

clang -rewriete-objc  main.m

sel_registerName("viewDidLoad")

xcode->Debug->DebugWorkflow->Always Shwo Disassembly 在断点处查看汇编代码

------------------------------------复习笔记------------------------------------
|-Block

|-Weak的底层实现
系统维护了一个容器来保存weak有关的数据。这里会采用原对象的指针作为key，weak对象的指针集合为value，所以这个容器应该是一个字典。value是一个集合，所以这里应该是一个数组
1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址
2、添加引用时：objc_initWeak函数会调用objc_storeWeak函数，objc_storeWeak函数的作用是更新指针对象，创建对应的弱引用表
3、释放时，调用clearDeallocating函数，clearDeallocating函数首先根据对象的地址获取所有weak指针地址的数组，遍历这个数组把其中的数据设置为nil，最后把这个entry从weak表中删除，最后清理对象的记录。

|-NSOperation
当挂起队列的时候，正在执行的操作是不会受影响的。
依赖
线程间通信

|-网络传输
HTTPS

|-RunLoop
循环会不会造成内存溢出
递归会不会造成溢出
递归和循环的区别：函数自己调用自己叫递归，函数调用需要划分一块栈区域，
RunLoop不能通过alloc init 方法创建
NSRunLoopCommonModes占位模式相当于UI模式和默认模式
初始化模式
内核模式
NSDefaultRunLoopMode
UITrackingRunLoopMode
RunLoop机制包含Source、Observer、Timer
默认模式：
UI模式：模式优先级最高，只能被触摸事件触发
没有开启RunLoop的Thread赋值给属性，只能保住OC对象，线程是由CPU调度的，是无法保持的
让线程有执行不完的任务，线程就不会释放了
线程上面的NSRunLoop默认是不循环的，要调用run方法
[[NSRunLoop currentRunLoop] run] 直接调用NSRunLoop的run方法之后这个线程永远都不会死掉
while（！_isFinished）{
[[NSRunLoop currentRunLoop]  runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.0001]];
}
在外部控制_isFinished的值来改变线程的生命周期

或者在线程里面调用[NSThread exit]退出线程
主线程也是可以退掉的
UI操作是线程不安全的，在子线程里面更新UI也是可以的，但是如果出现资源抢夺程序就会崩掉
线程间的通讯必须要用到RunLoop机制，直接在线程里面写一个死循环是不能保证线程从事件队列里面取事件

|-Runtime机制

|-KVO

|-KVC底层实现

|-SDWebImage

|-网络传输数据加密,对称加密和非对称加密
对称加密：加密和解密都是用的同样的秘钥，对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。
非对称加密：最常用的RSA加密算法。使用了一对秘钥，公钥和私钥。私钥只能由一方保管，而公钥则可以发送给任何请求人。非对称加密使用这一对秘钥的其中一个进行加密，而解密用另外一个。
可以采用MD5加密，简单的MD5加密可以通过碰撞检测破解，所以单纯的使用MD5加密，安全性非常差。
我们可以采用加盐（把要传输的数据MD5加密后在加上自定义一长串字符串再进行MD5加密）的方式增加复杂度，这样通过碰撞检测就不容易破解（如果盐被泄露了，这种加密方式就不安全了，所以这种方式存在很大的安全隐患）
我们可以在这种方式的基础上再增加复杂度。盐不写在应用程序里面，通过服务器分配，在注册的时候为没一位用户分配一个随机盐，这样即使盐泄露了也只是一个用户的数据不安全，不会造成批量用户的数据安全（但是这个还是存在一个问题，就是通过抓包软件，截取网络传输数据，模拟客户端请求）
我们可以通过增加时间戳的方式提高系统的安全性，在盐的基础上在加上一个时间戳（精确到分钟），服务器验证的时候验证服务器的当前时间和上一分钟，如果验证都失败了则认为验证失败。


------------------------------------复习笔记------------------------------------

